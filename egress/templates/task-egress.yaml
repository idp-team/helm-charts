---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: egress
  namespace: {{ .Values.app.namespace }}
spec:
  description: >-
    This task will take in the path to an existing yaml file in the filesystem,
    perform some logic to determine an unused IP, and write that to the file(s)
    provided in the output.

  params:
  - name: OUTPUT
    description: |
      The string containing the list of files to update.
    type: string

  - name: INPUT
    description: |
      The yaml file containing the list of existing egress ips
    type: string

  workspaces:
  - name: output
    description: workspace containing the git repo

  steps:
    - name: process-egress-ip
      image: registry.access.redhat.com/ubi8/python-38:1-34.1599745032
      workingDir: $(workspaces.output.path)
      script: |
        #!/usr/libexec/platform-python

        import ipaddress
        import yaml
        import re

        def load_yaml_file(filename):
            with open(filename, 'r') as file:
                return yaml.safe_load(file)

        def save_yaml_file(data, filename):
            with open(filename, 'w') as file:
                yaml.safe_dump(data, file)

        def load_ip_ranges(filename):
            data = load_yaml_file(filename)
            ip_ranges = {}
            for item in data['availableEgress']['ranges']:
                start_ip = ipaddress.ip_address(item['range']['start'])
                end_ip = ipaddress.ip_address(item['range']['end'])
                network = ipaddress.summarize_address_range(start_ip, end_ip)[0]
                ip_ranges[item['name']] = network
            return ip_ranges

        def load_used_ips(filenames):
            used_ips = {}
            file_data = {}
            for filename in filenames:
                data = load_yaml_file(filename)
                file_data[filename] = data
                for lob, apps in data['allocatedEgress']['ranges'].items():
                    if lob not in used_ips:
                        used_ips[lob] = set()
                    for app, details in apps.items():
                        used_ips[lob].add(details['backend-connections'])
            return used_ips, file_data

        def is_ip_in_use(ip, used_ips, network_name):
            return network_name in used_ips and str(ip) in used_ips[network_name]

        def get_next_available_ip(network, used_ips, network_name):
            for ip in network.hosts():
                if not is_ip_in_use(ip, used_ips, network_name):
                    return ip
            return None

        def find_available_ip(network_name, ip_ranges, used_ips):
            if network_name in ip_ranges:
                next_ip = get_next_available_ip(ip_ranges[network_name], used_ips, network_name)
                if next_ip:
                    return next_ip
                else:
                    return None
            else:
                return None

        def update_used_ips(file_data, filename, lob, app, new_ip):
            if lob not in file_data[filename]['allocatedEgress']['ranges']:
                file_data[filename]['allocatedEgress']['ranges'][lob] = {}
            file_data[filename]['allocatedEgress']['ranges'][lob][app] = {'backend-connections': str(new_ip)}
            save_yaml_file(file_data[filename], filename)

        def parse_inputs(input_string):
            pattern = r"lob:\s*(\w+)\s*cluster:\s*(\w+)\s*app:\s*(\w+)"
            match = re.search(pattern, input_string, re.IGNORECASE)
            if match:
                return match.groups()
            else:
                return None, None, None

        # Example input string
        input_string = """
          $(params.OUTPUT)
        """

        # Parsing inputs
        network_input, filename_input, app_input = parse_inputs(input_string)
        filename_input = f'used_{filename_input}.yaml'  # Assuming filename follows a specific format

        # Load data
        ip_ranges = load_ip_ranges('ip_ranges.yaml')
        used_ips, file_data = load_used_ips([f'used_cluster-1.yaml', f'used_cluster-2.yaml'])

        # Process
        if network_input and filename_input and app_input:
            available_ip = find_available_ip(network_input, ip_ranges, used_ips)
            if available_ip:
                update_used_ips(file_data, filename_input, network_input, app_input, available_ip)
                print(f"The next available IP in {network_input} for {app_input} has been allocated: {available_ip}")
            else:
                print("No available IPs in the specified range or network not found.")
        else:
            print("Invalid input format.")